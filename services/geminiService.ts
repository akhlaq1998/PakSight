
import { GoogleGenAI, GenerateContentResponse, Content } from "@google/genai";
import { GEMINI_MODEL_NAME } from '../constants';
import { GroundingChunk } from "../types";

const API_KEY = process.env.API_KEY;

if (!API_KEY) {
  console.warn("API_KEY environment variable not set. Gemini API calls will be mocked or may fail if not handled.");
}

const ai = new GoogleGenAI({ apiKey: API_KEY || "mock_api_key" }); // Provide a mock key if undefined to avoid constructor error

interface StrategicResponse {
  text: string;
  sources?: GroundingChunk[];
}

export const askStrategicQuestion = async (question: string): Promise<StrategicResponse> => {
  if (!API_KEY) { // Mock response if API key is not available
    console.log("Using MOCK response for Gemini API as API_KEY is not set.");
    return new Promise(resolve => setTimeout(() => resolve({
      text: `Mocked AI Response: Based on general knowledge, addressing "${question}" requires analyzing recent trends. Typically, sentiment might be mixed, focusing on economic potential versus security challenges. Ensure official sources are consulted for definitive analysis. The UI will list any specific web sources separately if available from grounding.`,
      sources: [{ web: { uri: "https://mock.example.com/report1", title: "Mock Official Report: Mideast Tensions - Example News" } }]
    }), 1000));
  }

  try {
    const systemInstructionText = `You are a highly sophisticated AI Strategic Assistant for senior diplomats, policymakers, and intelligence analysts. Your primary function is to provide in-depth, objective, and meticulously sourced foreign media intelligence. Analyze media coverage with precision, focusing on geopolitical, economic, security, and diplomatic implications.
Responses must be concise, factual, neutral, and devoid of casual language or speculation.
IMPORTANT CITATION INSTRUCTIONS:
1.  DO NOT embed any URLs or markdown links (e.g., [[Title](URL)]) directly within your main textual response.
2.  Within your narrative, you may refer to sources generally (e.g., "According to AP News...", "Reports indicate...").
3.  Specific, clickable source links with titles and URIs will be generated by the user interface based on the structured 'groundingChunks' data provided by the Google Search grounding tool. Your main text should be clean narrative.
When up-to-date information is critical (e.g., recent events, current sentiment), leverage Google Search grounding.
Present information clearly and authoritatively. For structured information or lists, consider using bullet points for clarity.`;
    
    const contents: Content[] = [{ role: "user", parts: [{ text: question }] }];

    const useSearch = question.toLowerCase().includes("recent") || 
                      question.toLowerCase().includes("latest") ||
                      question.toLowerCase().includes("current") ||
                      question.toLowerCase().includes("this week") ||
                      question.toLowerCase().includes("today");

    const requestConfig: { systemInstruction?: string | Content; tools?: any[]; } = {};

    if (useSearch) {
      requestConfig.tools = [{googleSearch: {}}];
      // System instruction is also passed when search is active,
      // as the previous restriction was to avoid *other* configs when tools are *the only other* config.
      // Now, systemInstruction is part of the base expectation.
      requestConfig.systemInstruction = systemInstructionText; 
    } else {
      requestConfig.systemInstruction = systemInstructionText;
    }
    
    // Omitting thinkingConfig to allow default (thinking enabled) for higher quality.

    const response: GenerateContentResponse = await ai.models.generateContent({
      model: GEMINI_MODEL_NAME,
      contents: contents,
      config: requestConfig,
    });

    const responseText = response.text;
    let sources: GroundingChunk[] | undefined = undefined;

    // Extract sources ONLY from groundingMetadata if search was used
    if (useSearch && response.candidates && response.candidates[0]?.groundingMetadata?.groundingChunks) {
       sources = response.candidates[0].groundingMetadata.groundingChunks
        .filter(chunk => chunk.web && chunk.web.uri && chunk.web.title) as GroundingChunk[];
    }
    
    return { text: responseText, sources };

  } catch (error) {
    console.error("Error calling Gemini API:", error);
    if (error instanceof Error) {
        const detailedError = (error as any).response?.data || (error as any).error || error;
        // Try to parse if detailedError is a stringified JSON
        let displayError = `Error processing your request.`;
        try {
            const parsedError = JSON.parse(String(detailedError));
            displayError = `Error: ${parsedError.message || JSON.stringify(parsedError)}`;
        } catch (e) {
            displayError = `Error processing your request: ${String(detailedError)}`;
        }
        return { text: displayError };
    }
    return { text: "An unknown error occurred while processing your request." };
  }
};
